// MultiplopiaViewer.cpp

#include <cstring>
#include <iostream>
#include <osg/Group>
#include <osg/PolygonStipple>
#include <osg/PolygonMode>
#include <osg/PositionAttitudeTransform>
#include <osgDB/ReadFile>
#include <osgViewer/Viewer>
#include <osg/Fog>
#include <osg/ref_ptr>
#include <osgGA/TrackballManipulator>
#include <osg/Shape>
#include <osg/ShapeDrawable>
#include <stdio.h>
#include "CcalculateBoundingBox.h"

using namespace std;

void printVec3(osg::Vec3 v)
{
    printf("%.2f, %.2f, %.2f\n", v.x(), v.y(), v.z());
}

osg::ref_ptr<osg::Geode> GetAxisGeode()
{
    osg::ref_ptr<osg::Geode> axisGeode(new osg::Geode);
    osg::ref_ptr<osg::Geometry> axisDraw(new osg::Geometry);
    auto axisState = axisDraw->getOrCreateStateSet();
    axisState->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
    osg::ref_ptr<osg::Vec3Array> lineVertices(new osg::Vec3Array(6));
    (*lineVertices)[0] = osg::Vec3(0, 10000, 0);
    (*lineVertices)[1] = osg::Vec3(0, -10000, 0);
    (*lineVertices)[2] = osg::Vec3(10000, 0, 0);
    (*lineVertices)[3] = osg::Vec3(-10000, 0, 0);
    (*lineVertices)[4] = osg::Vec3(0, 0, 10000);
    (*lineVertices)[5] = osg::Vec3(0, 0, -10000);
    axisDraw->setVertexArray(lineVertices);
    axisDraw->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::LINES, 0, 6));
    osg::ref_ptr<osg::Vec4Array> lineColors = (new osg::Vec4Array(1));
    (*lineColors)[0] = osg::Vec4(1, 1, 1, 1);
    axisDraw->setColorArray(lineColors);
    axisGeode->addDrawable(axisDraw);
    return axisGeode;
}

osg::Vec3 getPointOnBoundingSphere(const osg::BoundingSphere &bound, double theta, double phi)
{
    double radius = bound.radius();
    double x = radius * sin(theta) * cos(phi);
    double y = radius * sin(theta) * sin(phi);
    double z = radius * cos(theta);
    osg::Vec3 unitPosition(x, y, z);
    return unitPosition += bound.center();
}

osg::ref_ptr<osg::PositionAttitudeTransform>
CreateReplicaHelper(osg::ref_ptr<osg::Node> model, int axis, double translation)
{
    osg::ref_ptr<osg::PositionAttitudeTransform> rep1Trans(new osg::PositionAttitudeTransform);
//    osg::Vec3 rep1Pos = model->getBound().center() * osg::computeLocalToWorld(model->getParentalNodePaths()[0]);
//    printf("%.2f, %.2f, %.2f. Radius: %.2f\n", rep1Pos.x(), rep1Pos.y(), rep1Pos.z(), model->getBound().radius());
//
    CcalculateBoundingBox bbox;
    model->accept(bbox);
    osg::BoundingBox calcbbox = bbox.getBoundBox();
    osg::Vec3 rep1Pos = calcbbox.center();
    if(axis == 0)
    {
        rep1Pos.x() += translation;
    }
    else if(axis == 1)
    {
        rep1Pos.y() += translation;
    }
    else if(axis == 2)
    {
        rep1Pos.z() += translation;
    }
    else
    {
        exit(1);
    }
    rep1Trans->setPosition(rep1Pos);
    rep1Trans->addChild(model);
    return rep1Trans;
}

osg::ref_ptr<osg::Geode> getDrawBBoxGeode(osg::BoundingBox bbox)
{
    osg::ref_ptr<osg::Geode> geode(new osg::Geode);
    osg::ref_ptr<osg::Vec3Array> vertices(new osg::Vec3Array(8));
    
    for(int i = 0; i < 8; i++)
    {
        osg::Vec3 corner = bbox.corner(i);
        (*vertices)[i] = corner;
        printVec3(corner);
    }
    osg::ref_ptr<osg::Geometry> linesGeom(new osg::Geometry);
    auto linesStates = linesGeom->getOrCreateStateSet();
    osg::ref_ptr<osg::PolygonMode> polyMode(new osg::PolygonMode);
    polyMode->setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE);
    linesStates->setAttribute(polyMode);
    linesGeom->setVertexArray(vertices);
    
    // bottom
    osg::ref_ptr<osg::DrawElementsUInt> bottom(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    bottom->push_back(0);
    bottom->push_back(1);
    bottom->push_back(3);
    bottom->push_back(2);
    
    osg::ref_ptr<osg::DrawElementsUInt> upper(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    upper->push_back(4);
    upper->push_back(5);
    upper->push_back(7);
    upper->push_back(6);
    
    osg::ref_ptr<osg::DrawElementsUInt> left(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    left->push_back(0);
    left->push_back(2);
    left->push_back(6);
    left->push_back(4);
    
    osg::ref_ptr<osg::DrawElementsUInt> right(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    right->push_back(1);
    right->push_back(3);
    right->push_back(7);
    right->push_back(5);
    
    osg::ref_ptr<osg::DrawElementsUInt> front(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    front->push_back(0);
    front->push_back(1);
    front->push_back(5);
    front->push_back(4);
    
    osg::ref_ptr<osg::DrawElementsUInt> back(new osg::DrawElementsUInt(osg::PrimitiveSet::QUADS, 0));
    back->push_back(2);
    back->push_back(3);
    back->push_back(7);
    back->push_back(6);
    
    linesGeom->addPrimitiveSet(upper);
    linesGeom->addPrimitiveSet(bottom);
    linesGeom->addPrimitiveSet(left);
    linesGeom->addPrimitiveSet(right);
    linesGeom->addPrimitiveSet(front);
    linesGeom->addPrimitiveSet(back);
    
    geode->addDrawable(linesGeom);
    
    return geode;
}

int main(int argc, char **argv)
{
    if(argc != 2)
    {
        std::cerr << "Arg" << std::endl;
    }
    osg::ref_ptr<osg::Node> loadedModel = osgDB::readNodeFile(argv[1]);
    osg::ref_ptr<osg::Node> lampModel = osgDB::readNodeFile("robot.osg");
    
    osg::ref_ptr<osg::Group> sceneRoot(new osg::Group);
    sceneRoot->addChild(loadedModel);
    
    osg::ref_ptr<osg::LightSource> lightSource(new osg::LightSource);
    lightSource->addChild(lampModel);
    
    osg::ref_ptr<osg::Light> light = lightSource->getLight();
    light->setLightNum(0);
    light->setPosition(osg::Vec4(0, 0, 0, 1));
    light->setDiffuse(osg::Vec4(1, 0, 0, 1));
    
    osg::ref_ptr<osg::PositionAttitudeTransform> lightPosTrans(new osg::PositionAttitudeTransform);
    lightPosTrans->addChild(lightSource);
    lightPosTrans->setPosition(osg::Vec3(0, 0, 20));
    sceneRoot->addChild(lightPosTrans);
    
    sceneRoot->getOrCreateStateSet()->setMode(GL_LIGHT0, osg::StateAttribute::ON);
    osgViewer::Viewer viewer;
    viewer.setSceneData(sceneRoot);
    viewer.run();
}

//int main(int argc, char* argv[])
//{
//    if(argc != 2)
//    {
//        std::cerr << "Argument!" << std::endl;
//        exit(1);
//    }
//    osg::ref_ptr<osg::Node> loadedModel = osgDB::readNodeFile(argv[1]);
//    if(!loadedModel)
//    {
//        std::cerr << "Error loading model" << std::endl;
//        exit(1);
//    }
//    
//    osg::ref_ptr<osg::Group> sceneRoot(new osg::Group);
//    
//    // add axis
//    sceneRoot->addChild(GetAxisGeode());
//    
//    // add models
//    sceneRoot->addChild(loadedModel);
//    auto modelBound = loadedModel->getBound();
//    
//    osg::ref_ptr<osg::Sphere> box(new osg::Sphere(modelBound.center(), modelBound.radius()));
//    osg::ref_ptr<osg::Box> box1(new osg::Box(modelBound.center(), modelBound.radius()*2));
//    osg::ref_ptr<osg::ShapeDrawable> shapeDraw(new osg::ShapeDrawable);
//    shapeDraw->setShape(box);
//    osg::ref_ptr<osg::ShapeDrawable> shapeDraw2(new osg::ShapeDrawable);
//    shapeDraw2->setShape(box1);
//    osg::ref_ptr<osg::Geode> boxGeode(new osg::Geode);
//    osg::ref_ptr<osg::PolygonMode> polyMode(new osg::PolygonMode);
//    polyMode->setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE);
//    boxGeode->getOrCreateStateSet()->setAttribute(polyMode);
//    boxGeode->addDrawable(shapeDraw);
//    boxGeode->addDrawable(shapeDraw2);
//    sceneRoot->addChild(boxGeode);
//    
//    
//    osg::ref_ptr<osg::Group> replicas(new osg::Group);
//    auto repStates = replicas->getOrCreateStateSet();
//    repStates->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
//    
//    auto repXTrans = CreateReplicaHelper(loadedModel, 0, 20);
//    replicas->addChild(repXTrans);
//    auto repMXTrans = CreateReplicaHelper(loadedModel, 0, -20);
//    replicas->addChild(repMXTrans);
//    auto repYTrans = CreateReplicaHelper(loadedModel, 1, 20);
//    replicas->addChild(repYTrans);
//    auto repMYTrans = CreateReplicaHelper(loadedModel, 1, -20);
//    replicas->addChild(repMYTrans);
//    auto repZTrans = CreateReplicaHelper(loadedModel, 2, 20);
//    replicas->addChild(repZTrans);
//    auto repMZTrans = CreateReplicaHelper(loadedModel, 2, -20);
//    replicas->addChild(repMZTrans);
//    
//    sceneRoot->addChild(replicas);
//    
//    osgViewer::Viewer viewer;
//    viewer.setSceneData(sceneRoot);
//    
//    osg::Vec3 pointOnBoundingSphere = getPointOnBoundingSphere(modelBound, osg::PI_4, osg::PI_4);
//    pointOnBoundingSphere.y() = -pointOnBoundingSphere.y();
//    
//    osg::Vec3 eye = pointOnBoundingSphere * 10;
//    osg::Vec3 center(modelBound.center());
//    osg::Vec3 up(0, 0, 1);
//   
//    viewer.setCameraManipulator(new osgGA::TrackballManipulator);
//    viewer.getCameraManipulator()->setHomePosition(eye, center, up);
//    viewer.run();
//    
//    return 0;
//}